<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.3">


  <link rel="mask-icon" href="/images/favicon.ico?v=5.1.3" color="#222">





  <meta name="keywords" content="JS,ES5,读书笔记," />










<meta name="description" content="所有方法 Object.defineProperty() Object.definePropertise() Object.getOwnPropertyDescriptor() Object.getPrototypeOf() instanceof isPrototypeOf() hasOwnProperty() in">
<meta name="keywords" content="JS,ES5,读书笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="读书笔记：ES5-面向对象">
<meta property="og:url" content="http://www.yvonne.party/2018/03/22/ES5-面向对象/index.html">
<meta property="og:site_name" content="Yvonne">
<meta property="og:description" content="所有方法 Object.defineProperty() Object.definePropertise() Object.getOwnPropertyDescriptor() Object.getPrototypeOf() instanceof isPrototypeOf() hasOwnProperty() in">
<meta property="og:image" content="http://www.yvonne.party/img/blogImg/object-oriented/object-oriented1.jpeg">
<meta property="og:image" content="http://www.yvonne.party/img/blogImg/object-oriented/object-oriented2.jpeg">
<meta property="og:image" content="http://www.yvonne.party/img/blogImg/object-oriented/object-oriented3.jpeg">
<meta property="og:image" content="http://www.yvonne.party/img/blogImg/object-oriented/object-oriented4.jpeg">
<meta property="og:image" content="http://www.yvonne.party/img/blogImg/object-oriented/object-oriented5.jpeg">
<meta property="og:image" content="http://www.yvonne.party/img/blogImg/object-oriented/object-oriented6.jpeg">
<meta property="og:image" content="http://www.yvonne.party/img/blogImg/object-oriented/object-oriented9.jpeg">
<meta property="og:image" content="http://www.yvonne.party/img/blogImg/object-oriented/object-oriented7.jpeg">
<meta property="og:image" content="http://www.yvonne.party/img/blogImg/object-oriented/object-oriented8.jpeg">
<meta property="og:image" content="http://www.yvonne.party/img/blogImg/object-oriented/object-oriented10.jpeg">
<meta property="og:image" content="http://www.yvonne.party/img/blogImg/object-oriented/object-oriented11.jpeg">
<meta property="og:image" content="http://www.yvonne.party/img/blogImg/object-oriented/object-oriented12.jpeg">
<meta property="og:image" content="http://www.yvonne.party/img/blogImg/object-oriented/object-oriented13.jpeg">
<meta property="og:image" content="http://www.yvonne.party/img/blogImg/object-oriented/object-oriented14.jpeg">
<meta property="og:image" content="http://www.yvonne.party/img/blogImg/object-oriented/object-oriented15.jpeg">
<meta property="og:image" content="http://www.yvonne.party/img/blogImg/object-oriented/object-oriented16.jpeg">
<meta property="og:image" content="http://www.yvonne.party/img/blogImg/object-oriented/object-oriented17.jpeg">
<meta property="og:image" content="http://www.yvonne.party/img/blogImg/object-oriented/object-oriented18.jpeg">
<meta property="og:image" content="http://www.yvonne.party/img/blogImg/object-oriented/object-oriented19.jpeg">
<meta property="og:image" content="http://www.yvonne.party/img/blogImg/object-oriented/object-oriented19.jpeg">
<meta property="og:updated_time" content="2018-04-30T15:02:16.879Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="读书笔记：ES5-面向对象">
<meta name="twitter:description" content="所有方法 Object.defineProperty() Object.definePropertise() Object.getOwnPropertyDescriptor() Object.getPrototypeOf() instanceof isPrototypeOf() hasOwnProperty() in">
<meta name="twitter:image" content="http://www.yvonne.party/img/blogImg/object-oriented/object-oriented1.jpeg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.yvonne.party/2018/03/22/ES5-面向对象/"/>





  <title>读书笔记：ES5-面向对象 | Yvonne</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Yvonne</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.yvonne.party/2018/03/22/ES5-面向对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yvonne">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yvonne">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">读书笔记：ES5-面向对象</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-22T23:34:29+08:00">
                2018-03-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="所有方法"><a href="#所有方法" class="headerlink" title="所有方法"></a>所有方法</h3><ul>
<li><code>Object.defineProperty()</code></li>
<li><code>Object.definePropertise()</code></li>
<li><code>Object.getOwnPropertyDescriptor()</code></li>
<li><code>Object.getPrototypeOf()</code></li>
<li><code>instanceof</code></li>
<li><code>isPrototypeOf()</code></li>
<li><code>hasOwnProperty()</code></li>
<li><code>in</code><a id="more"></a></li>
<li><code>for-in</code></li>
<li><code>Object.keys()</code></li>
<li><code>Object.getOwnPropertyNames()</code></li>
<li><code>Object.create()</code></li>
</ul>
<h3 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h3><h4 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h4><p>ES有两种属性：数据属性/访问器属性<br>默认对象字面量设置的属性都是数据属性，访问器属性需要<code>defineProperty()</code>/<code>definePropertise()</code>方法设置</p>
<p>数据属性：包含一个数据值的位置，此位置可以读取和写入<br>定义行为的特征值有以下：<br><code>[[Configurable]]</code> 是否能通过<code>delete</code>删除属性从而重新定义属性，能否修改属性的特性，或者能否修改为访问器属性。开发人员直接在对象定义的属性该特性默认值是<code>true</code><br><code>[[Enumerable]]</code> 能否通过<code>for-in</code>返回。…默认值是<code>true</code><br><code>[[Writable]]</code> 能否修改属性的值。…默认值是<code>true</code><br><code>[[Value]]</code> 包含属性的数据值，读取和修改就在此位置。…默认值是<code>undefined</code></p>
<p>修改属性特性方法： <code>Object.defineProperty()</code>，参数一对象，参数二属性名，参数三特性对象（可设置一或多个值）<br>⚠️IE9+<br>⚠️特性对象中不指定的特性默认是<code>false</code>/<code>undefined</code></p>
<p><img src="/img/blogImg/object-oriented/object-oriented1.jpeg"></p>
<p>访问器属性：包含一对<code>getter()</code>/<code>setter()</code>函数，不包含数据值<br>定义行为的特征值有以下：<br><code>[[Configurable]]</code> 是否能通过<code>delete</code>删除属性从而重新定义属性，能否修改属性的特性，或者能否修改为数据属性。开发人员直接在对象定义的属性该特性默认值是<code>true</code><br><code>[[Enumerable]]</code> 能否通过<code>for-in</code>返回。…默认值是<code>true</code><br><code>[[get]]</code> 读取属性时调用的函数，默认值<code>undefined</code><br><code>[[set]]</code> 写入属性时调用的函数，默认值<code>undefined</code></p>
<p>利用<code>Object.defineProperty()</code>设置特性，不设置<code>get</code>不能读，不设置<code>set</code>不能写：</p>
<p><img src="/img/blogImg/object-oriented/object-oriented2.jpeg"></p>
<p>一次性定义多个属性：<code>Object.definePropertise()</code> 参数一对象，参数二（属性：特性对象）格式的对象<br>⚠️IE9+<br>⚠️可以针对任何对象包括DOM/BOM使用此方法</p>
<p><img src="/img/blogImg/object-oriented/object-oriented3.jpeg"></p>
<p>读取属性特性：<code>Object.getOwnPropertyDescriptor()</code> 参数一对象，参数二属性名，返回特性对象，<strong>仅是实例的非原型的属性描述</strong>，想返回原型上的属性描述则直接在原型上调用<br>⚠️IE9+</p>
<p><img src="/img/blogImg/object-oriented/object-oriented4.jpeg"></p>
<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>Object构造函数或者对象字面量创建单个对象缺点：同一个接口创建很多对象，产生大量的重复代码</p>
<h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function createPerson(name,age)&#123;</span><br><span class="line">  var o = new Object();</span><br><span class="line"></span><br><span class="line">  o.name = name;</span><br><span class="line">  o.age = age;</span><br><span class="line">  o.sayName = function()&#123;</span><br><span class="line">  	console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/blogImg/object-oriented/object-oriented5.jpeg"></p>
<p><strong>解决：封装函数，创建多个相似对象<br>问题：对象识别问题-怎样知道对象类型</strong></p>
<h4 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function CreatePerson(name,age)&#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">  this.sayName = function()&#123;</span><br><span class="line">  	console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/blogImg/object-oriented/object-oriented6.jpeg"></p>
<p>⚠️构造函数规定大写字母开头，为了区别于其他函数，<strong>构造函数本身也是函数，只不过是用途于创建对象</strong><br>⚠️<code>new</code>调用构造函数过程：<br> 1.创建一个新对象<br> 2.构造函数作用域指向新对象<br> 3.执行构造函数中代码<br> 4.返回新对象<br>⚠️不存在构造函数特殊语法，<strong>通过<code>new</code>调用就是构造函数，不通过<code>new</code>调用就是普通函数</strong></p>
<p><strong>解决：实例标识为一种特定类型，能够<code>instanceof</code>判断具体对象类型<br>问题：每个实例上都实例化一遍函数对象，创建多个同样功能的函数没有必要，也不必要耦合函数方法和对象</strong>(在构造函数外即全局作用域下写函数方法，然后在构造函数中定义新对象方法时指向全局函数，并不是好方法，虽然解决了共享同一个方法，但是全局函数仅被某个对象使用导致全局作用域名副其实、同时会污染全局环境、也失去了自定义的引用类型的封装性)</p>
<h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><h5 id="理解原型"><a href="#理解原型" class="headerlink" title="理解原型"></a>理解原型</h5><p>过程：<br>创建一个新函数，根据一组特定规则为该函数创建属性<code>prototype</code>，属性是指向原型对象的指针<br>原型对象自动获取<code>constructor</code>(构造函数)属性，是指向新函数的指针，其他方法均继承自<code>Object</code><br>创建新实例，实例将包含<code>[[prototype]]</code>内部属性指针，指向原型，使其与原型关联(并非与构造函数关联)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = &apos;Nicholas&apos;;</span><br><span class="line">Person.prototype.age = 29;</span><br><span class="line">Person.prototype.job = &apos;software Engineer&apos;;</span><br><span class="line">Person.prototype.sayName = function()&#123;</span><br><span class="line">  console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person1 = new Person();</span><br><span class="line">var person2 = new Person();</span><br></pre></td></tr></table></figure>
<p><img src="/img/blogImg/object-oriented/object-oriented9.jpeg"></p>
<p><img src="/img/blogImg/object-oriented/object-oriented7.jpeg"></p>
<p><code>Object.getPrototypeOf()</code> 获取实例的原型，IE9+<br><img src="/img/blogImg/object-oriented/object-oriented8.jpeg"></p>
<p>读取对象属性过程：<br>搜索实例本身 =&gt; 搜索原型对象</p>
<p>⚠️原型最初只包含<code>constructor</code>，这个属性也是被实例共享的，所以实例可以<code>person1.constructor</code>访问到构造函数，即进行了两次搜索在原型中找到该属性</p>
<p>⚠️可以通过实例访问到原型中的值，但不能通过实例更改原型中的值，即实例属性会屏蔽原型中的属性访问(这也是上面提到的访问属性过程中，第一次搜索实例本身就有则不再继续搜索)</p>
<p><img src="/img/blogImg/object-oriented/object-oriented10.jpeg"></p>
<h5 id="各种获取属性方法"><a href="#各种获取属性方法" class="headerlink" title="各种获取属性方法"></a>各种获取属性方法</h5><p><code>in</code>操作符： <code>for-in</code>循环/单独使用<br>-单独使用： 属性在对象中返回<code>true</code>，<strong>包括原型中存在</strong></p>
<p>⚠️可以通过<code>hasOwnProperty()</code>方法和<code>in</code>操作符可以确认属性存在实例中还是原型中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function hasPrototypeProperty(object,name)&#123;</span><br><span class="line">  return !object.hasOwnProperty(name) &amp;&amp; name in object</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/blogImg/object-oriented/object-oriented11.jpeg"></p>
<p>-<code>for-in</code>循环： 返回所有可枚举属性数组，<strong>包括原型中属性</strong></p>
<p>其他相关方法：<code>Object.keys()</code>返回实例的所有可枚举属性；<code>Object.getOwnPropertyNames</code>返回实例中所有属性数组（无论是否可枚举）<br><img src="/img/blogImg/object-oriented/object-oriented12.jpeg"></p>
<h5 id="更简单的原型语法-原型动态性"><a href="#更简单的原型语法-原型动态性" class="headerlink" title="更简单的原型语法/原型动态性"></a>更简单的原型语法/原型动态性</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 视觉的封装性 --&gt;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  name: &apos;Nicholas&apos;,</span><br><span class="line">  age: 29,</span><br><span class="line">  job:&apos;software Engineer&apos;,</span><br><span class="line">  sayName: function()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person1 = new Person();</span><br><span class="line">var person2 = new Person();</span><br></pre></td></tr></table></figure>
<p>⚠️上述写法其实是重写了<code>Person</code>原型，新原型是<code>Object</code>字面量对象实例，此实例自动获取的<code>constructor</code>(其实是实例的原型自动获取的属性)指向<code>Object</code>并非<code>Person</code>，但并不影响<code>instanceof</code>返回值，如果<code>constructor</code>很重要可以重写原型时重新定义(暂时不知道有何用处)，但是字面量定义会导致其可枚举，可以通过<code>defineProperty</code>方法定义不可枚举属性</p>
<p>⚠️在原型中查找值是一次性的搜索，所以先创建实例，后改动原型也会在实例中反应，但是重写原型会导致原创建实例与新原型无关联，原创建实例的<code>[[prototype]]</code>依然指向的是原来自动生成的原型，注意重写原型要在创建实例之前</p>
<p><img src="/img/blogImg/object-oriented/object-oriented13.jpeg"></p>
<p>⚠️原生引用类型也是采用原型模式创建的，都在构造函数的原型上定义了方法，但是不推荐修改原生对象原型！！！</p>
<p><strong>解决：所有实例通过原型共享属性和方法<br>问题：由于原型属性被共享的特性，对于引用类型比如数组，一个实例<code>push</code>修改了数组，另个实例上也能反应出来(重新在实例上创建属性不存在这种问题，因为可以屏蔽原型属性)</strong><br><img src="/img/blogImg/object-oriented/object-oriented14.jpeg"></p>
<h4 id="组合使用构造函数模式和原型模式"><a href="#组合使用构造函数模式和原型模式" class="headerlink" title="组合使用构造函数模式和原型模式"></a>组合使用构造函数模式和原型模式</h4><p>构造函数用于定义实例属性、原型模式用于定义方法和共享的属性，最大限度节省内存<br>还可以向构造函数传递参数<br>是使用最广泛、认同度最高的一种创建自定义类型的方法-默认模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age)&#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">  this.friends = [&apos;xiaohei&apos;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  constructor: Person,</span><br><span class="line">  sayName : function()&#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/blogImg/object-oriented/object-oriented15.jpeg"></p>
<h4 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h4><p>所有信息都放在构造函数中，仅在必要情况下，才在构造函数中初始化原型，同时保留了构造函数和原型的优点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,job)&#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">  this.job = job;</span><br><span class="line"></span><br><span class="line">  if(typeof this.sayName != &apos;function&apos;)&#123;</span><br><span class="line">    Person.prototype.sayName = function()&#123;</span><br><span class="line">      console.log(this.name);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/blogImg/object-oriented/object-oriented16.jpeg"></p>
<h4 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 除了要使用new操作符并叫其构造函数外，和工厂模式没有差别 --&gt;</span><br><span class="line">function Person(name,age)&#123;</span><br><span class="line">  var o = new Object();</span><br><span class="line"></span><br><span class="line">  o.name = name;</span><br><span class="line">  o.age = age;</span><br><span class="line">  o.sayName = function()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 不写返回值的情况下构造函数回自动返回新对象实例，但这里重写了返回值 --&gt;</span><br><span class="line">  return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般用来应对特殊情况，比如生成包含额外方法的数组<br><img src="/img/blogImg/object-oriented/object-oriented17.jpeg"></p>
<p>⚠️能使用其他模式的情况下不要使用这种模式，不能通过<code>instanceof</code>确定对象类型</p>
<h4 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h4><p>稳妥对象：没有公共属性、不引用<code>this</code>。适合在安全环境或者防止数据被其他应用程序改动时使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age)&#123;</span><br><span class="line">  var o = new Object();</span><br><span class="line">  &lt;!-- 可以在此定义私有变量和函数 --&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 和寄生模式相比差距一添加实例方法不用this --&gt;</span><br><span class="line">  o.sayName = function()&#123;</span><br><span class="line">    console.log(name);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 差距二不使用new调用构造函数 --&gt;</span><br><span class="line">var person1 = Person(&apos;xiaohei&apos;,25)</span><br></pre></td></tr></table></figure></p>
<p>⚠️这种方式，除了使用实例的<code>sayName</code>方法外没有别的途径能访问<code>name</code>属性、即便能为对象添加其他属性，也不能更改原始属性数据<br>以上其实是闭包原理</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>oo语言支持两种继承方式：接口继承-继承方法的签名；实现继承-继承实际的方法<br>ES只支持实现继承，主要依靠原型链实现</p>
<h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><h5 id="基本模式"><a href="#基本模式" class="headerlink" title="基本模式"></a>基本模式</h5><p>引用类型A继承引用类型B，重写A的原型是B的实例，作为B的实例，A的原型指向B的原型，如此可以层层递进，构成了实例与原型的链条</p>
<p>基本模式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function SuperType()&#123;</span><br><span class="line">  this.property = true;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = function()&#123;</span><br><span class="line">  return this.property;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function SubType()&#123;</span><br><span class="line">  this.subproperty = false;</span><br><span class="line">&#125;</span><br><span class="line">&lt;!-- 重写原型实现继承 --&gt;</span><br><span class="line">SubType.prototype = new SuperType();</span><br><span class="line">&lt;!-- 继承的基础上添加了自己的方法 --&gt;</span><br><span class="line">SubType.prototype.getSubValue = function()&#123;</span><br><span class="line">  return this.subproperty;</span><br><span class="line">&#125;</span><br><span class="line">var instance = new SubType();</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/blogImg/object-oriented/object-oriented18.jpeg"><br>⚠️重写的原型没有<code>constructor</code>指向SubType构造函数，而作为SuperType的实例能访问到SuperType原型的<code>constructor</code>指向SuperType构造函数<br>⚠️重写的原型作为SuperType的实例，存在<code>[[prototype]]</code>内部属性指向SuperType原型<br>⚠️所有引用类型都继承Object，也是通过原型链实现的，所以SuperType原型是作为Object的实例存在的，存在<code>[[prototype]]</code>内部属性指向Object原型<br>⚠️继承的基础上添加自己的方法一定要在重写原型之后，添加的方式不能是字面量方式，那是又一次重写原型了！！！</p>
<h5 id="确定原型与实例关系"><a href="#确定原型与实例关系" class="headerlink" title="确定原型与实例关系"></a>确定原型与实例关系</h5><p>方法一： <code>instanceof</code><br>通过与原型链中出现的构造函数关系确定</p>
<p>方法二：<code>isPrototypeOf</code><br>通过与原型链中出现的原型关系确定</p>
<h5 id="原型链问题"><a href="#原型链问题" class="headerlink" title="原型链问题"></a>原型链问题</h5><p>问题一：引用类型副作用<br><img src="/img/blogImg/object-oriented/object-oriented19.jpeg"></p>
<p>问题二：无法在不影响所有对象实例的情况下，向超类型构造函数传递参数</p>
<h4 id="借用构造函数-经典继承-伪造对象"><a href="#借用构造函数-经典继承-伪造对象" class="headerlink" title="借用构造函数(经典继承/伪造对象)"></a>借用构造函数(经典继承/伪造对象)</h4><p>在子类型构造函数中调用超类型构造函数(利用<code>call</code>或<code>apply</code>当作普通函数调用)</p>
<h5 id="基本模式-1"><a href="#基本模式-1" class="headerlink" title="基本模式"></a>基本模式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function SuperType(name)&#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function SubType()&#123;</span><br><span class="line">  &lt;!-- 继承了SuperType --&gt;</span><br><span class="line">  &lt;!-- 当作普通函数来调用，其实是在为SubType实例创建自己的属性而已 --&gt;</span><br><span class="line">  &lt;!-- 也能传递参数 --&gt;</span><br><span class="line">  SuperType.call(this,&apos;xiaohei&apos;);</span><br><span class="line">  this.age = 25;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><p>依然是构造函数模式的问题，函数复用无从谈起</p>
<h4 id="组合继承-伪经典继承"><a href="#组合继承-伪经典继承" class="headerlink" title="组合继承(伪经典继承)"></a>组合继承(伪经典继承)</h4><p>原型链实现对原型属性和方法的继承，借用构造函数实现对实例属性的继承，保证了既有函数复用又有实例自己的属性<br>最常用的继承模式</p>
<h5 id="基本模式-2"><a href="#基本模式-2" class="headerlink" title="基本模式"></a>基本模式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function SuperType(name)&#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.colors = [&apos;grey&apos;,&apos;pink&apos;];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = function()&#123;</span><br><span class="line">  console.log(this.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function SubType(name,age)&#123;</span><br><span class="line">  &lt;!-- 2但是在这里为实例加入了name和colors属性，屏蔽了原型中同名属性的访问 --&gt;</span><br><span class="line">  SuperType.call(this,name);</span><br><span class="line">  this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">&lt;!-- 1其实这里执行new SuperType()为SubType原型加入了name和colors属性 --&gt;</span><br><span class="line">SubType.prototype = new SuperType();</span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line">SubType.prototype.sayAge = function()&#123;</span><br><span class="line">  console.log(this.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h4><p>借助原型，基于已有对象创建新对象，同时不必创建自定义类型</p>
<h5 id="基本模式-3"><a href="#基本模式-3" class="headerlink" title="基本模式"></a>基本模式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 称之为对o进行了一次浅复制 --&gt;</span><br><span class="line">function object(o)&#123;</span><br><span class="line">  &lt;!-- 临时F构造函数 --&gt;</span><br><span class="line">  function F()&#123;&#125;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 重写F构造函数原型 --&gt;</span><br><span class="line">  F.prototype = o;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 返回F实例，实例的[[prototype]]指向o --&gt;</span><br><span class="line">  return new F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>⚠️通过这种方式传入相同的对象而创建的对象实例原型指向同一个，共享原型方法和属性，所以就像原型模式一样存在引用类型副作用</p>
<h5 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create"></a>Object.create</h5><p>ES5新增<code>Object.create()</code>方法规范了原型式继承，参数一：原型对象，参数二(可选)：新对象实例额外属性的对象(同<code>Object.definePropertise()</code>第二个参数形式一样)<br>IE9+<br><img src="/img/blogImg/object-oriented/object-oriented19.jpeg"></p>
<p>⚠️在不需要兴师动众创建构造函数，只想让一个对象与另一个对象保持类似的情况下，可以胜任</p>
<h4 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h4><p>与原型模式紧密相关的一种思路<br>和寄生构造函数和工厂模式类似，仅用于封装继承过程，增强对象</p>
<h5 id="基本模式-4"><a href="#基本模式-4" class="headerlink" title="基本模式"></a>基本模式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function createAnother(original)&#123;</span><br><span class="line">  &lt;!-- 任何返回新对象的函数都可以，这里用了原型式继承 --&gt;</span><br><span class="line">  var clone = object(original);</span><br><span class="line">  clone.sayHi = function()&#123;</span><br><span class="line">    console.log(&apos;hi&apos;);</span><br><span class="line">  &#125;;</span><br><span class="line">  return clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>⚠️这种方式增强对象方法，与构造函数函数模式类似的点是函数不会得到复用<br>⚠️主要考虑对象，而不是自定义类型和构造函数的情况下，此方式是有用的模式</p>
<h4 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h4><p>最理想的继承范式<br>此方法为解决组合继承的问题（调用两次超类型构造函数，第一次重写子类型原型时使其作为超类型的实例具有超类型的属性，第二次创建子类型实例时又使实例重写了原型属性）</p>
<p>使用借用构造函数继承属性，原型链的混成模式继承方法，基本思路是重写子类型原型时不调用超类型构造函数，实际需要的是超类型原型的副本，可以使用寄生式继承来继承超类型原型，然后将结果指定给子类型的原型</p>
<h5 id="基本模式-5"><a href="#基本模式-5" class="headerlink" title="基本模式"></a>基本模式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function inheritPrototype(subType,superType)&#123;</span><br><span class="line">  &lt;!-- 创建原型是superType.prototype的prototype对象，即是前面原型式继承所说的浅复制 --&gt;</span><br><span class="line">  var prototype = Object(superType.prototype);</span><br><span class="line"></span><br><span class="line">  prototype.constructor = subType;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 结果指定给子类型的原型，使其子类型的原型指向超类型的原型，维持了原型链 --&gt;</span><br><span class="line">  subType.prototype = prototype;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用上面方法替换调用超类型构造函数重写子类型原型即可</p>
<p>⚠️此方法的高效在于只调用一次超类型构造函数，避免在子类型原型上创建不必要的、多余的属性</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JS/" rel="tag"># JS</a>
          
            <a href="/tags/ES5/" rel="tag"># ES5</a>
          
            <a href="/tags/读书笔记/" rel="tag"># 读书笔记</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/03/11/ES5-单体内置对象/" rel="next" title="读书笔记：ES5-单体内置对象">
                <i class="fa fa-chevron-left"></i> 读书笔记：ES5-单体内置对象
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/04/30/ES5-BOM-window/" rel="prev" title="ES5-BOM-window">
                ES5-BOM-window <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Inhaltsverzeichnis
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Übersicht
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpeg"
                alt="Yvonne" />
            
              <p class="site-author-name" itemprop="name">Yvonne</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">26</span>
                  <span class="site-state-item-name">Artikel</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">Tags</span>
                
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/Flona" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://linll.github.io" target="_blank" title="LGrok">
                    
                      <i class="fa fa-fw fa-globe"></i>LGrok</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://hedychen.github.io" target="_blank" title="Hedychen">
                    
                      <i class="fa fa-fw fa-globe"></i>Hedychen</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="http://blog.8i88.cn" target="_blank" title="Armo">
                    
                      <i class="fa fa-fw fa-globe"></i>Armo</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#所有方法"><span class="nav-number">1.</span> <span class="nav-text"><a href="#&#x6240;&#x6709;&#x65B9;&#x6CD5;" class="headerlink" title="&#x6240;&#x6709;&#x65B9;&#x6CD5;"></a>&#x6240;&#x6709;&#x65B9;&#x6CD5;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#理解对象"><span class="nav-number">2.</span> <span class="nav-text"><a href="#&#x7406;&#x89E3;&#x5BF9;&#x8C61;" class="headerlink" title="&#x7406;&#x89E3;&#x5BF9;&#x8C61;"></a>&#x7406;&#x89E3;&#x5BF9;&#x8C61;</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#属性类型"><span class="nav-number">2.1.</span> <span class="nav-text"><a href="#&#x5C5E;&#x6027;&#x7C7B;&#x578B;" class="headerlink" title="&#x5C5E;&#x6027;&#x7C7B;&#x578B;"></a>&#x5C5E;&#x6027;&#x7C7B;&#x578B;</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建对象"><span class="nav-number">3.</span> <span class="nav-text"><a href="#&#x521B;&#x5EFA;&#x5BF9;&#x8C61;" class="headerlink" title="&#x521B;&#x5EFA;&#x5BF9;&#x8C61;"></a>&#x521B;&#x5EFA;&#x5BF9;&#x8C61;</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#工厂模式"><span class="nav-number">3.1.</span> <span class="nav-text"><a href="#&#x5DE5;&#x5382;&#x6A21;&#x5F0F;" class="headerlink" title="&#x5DE5;&#x5382;&#x6A21;&#x5F0F;"></a>&#x5DE5;&#x5382;&#x6A21;&#x5F0F;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#构造函数模式"><span class="nav-number">3.2.</span> <span class="nav-text"><a href="#&#x6784;&#x9020;&#x51FD;&#x6570;&#x6A21;&#x5F0F;" class="headerlink" title="&#x6784;&#x9020;&#x51FD;&#x6570;&#x6A21;&#x5F0F;"></a>&#x6784;&#x9020;&#x51FD;&#x6570;&#x6A21;&#x5F0F;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#原型模式"><span class="nav-number">3.3.</span> <span class="nav-text"><a href="#&#x539F;&#x578B;&#x6A21;&#x5F0F;" class="headerlink" title="&#x539F;&#x578B;&#x6A21;&#x5F0F;"></a>&#x539F;&#x578B;&#x6A21;&#x5F0F;</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#理解原型"><span class="nav-number">3.3.1.</span> <span class="nav-text"><a href="#&#x7406;&#x89E3;&#x539F;&#x578B;" class="headerlink" title="&#x7406;&#x89E3;&#x539F;&#x578B;"></a>&#x7406;&#x89E3;&#x539F;&#x578B;</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#各种获取属性方法"><span class="nav-number">3.3.2.</span> <span class="nav-text"><a href="#&#x5404;&#x79CD;&#x83B7;&#x53D6;&#x5C5E;&#x6027;&#x65B9;&#x6CD5;" class="headerlink" title="&#x5404;&#x79CD;&#x83B7;&#x53D6;&#x5C5E;&#x6027;&#x65B9;&#x6CD5;"></a>&#x5404;&#x79CD;&#x83B7;&#x53D6;&#x5C5E;&#x6027;&#x65B9;&#x6CD5;</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#更简单的原型语法-原型动态性"><span class="nav-number">3.3.3.</span> <span class="nav-text"><a href="#&#x66F4;&#x7B80;&#x5355;&#x7684;&#x539F;&#x578B;&#x8BED;&#x6CD5;-&#x539F;&#x578B;&#x52A8;&#x6001;&#x6027;" class="headerlink" title="&#x66F4;&#x7B80;&#x5355;&#x7684;&#x539F;&#x578B;&#x8BED;&#x6CD5;/&#x539F;&#x578B;&#x52A8;&#x6001;&#x6027;"></a>&#x66F4;&#x7B80;&#x5355;&#x7684;&#x539F;&#x578B;&#x8BED;&#x6CD5;/&#x539F;&#x578B;&#x52A8;&#x6001;&#x6027;</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#组合使用构造函数模式和原型模式"><span class="nav-number">3.4.</span> <span class="nav-text"><a href="#&#x7EC4;&#x5408;&#x4F7F;&#x7528;&#x6784;&#x9020;&#x51FD;&#x6570;&#x6A21;&#x5F0F;&#x548C;&#x539F;&#x578B;&#x6A21;&#x5F0F;" class="headerlink" title="&#x7EC4;&#x5408;&#x4F7F;&#x7528;&#x6784;&#x9020;&#x51FD;&#x6570;&#x6A21;&#x5F0F;&#x548C;&#x539F;&#x578B;&#x6A21;&#x5F0F;"></a>&#x7EC4;&#x5408;&#x4F7F;&#x7528;&#x6784;&#x9020;&#x51FD;&#x6570;&#x6A21;&#x5F0F;&#x548C;&#x539F;&#x578B;&#x6A21;&#x5F0F;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#动态原型模式"><span class="nav-number">3.5.</span> <span class="nav-text"><a href="#&#x52A8;&#x6001;&#x539F;&#x578B;&#x6A21;&#x5F0F;" class="headerlink" title="&#x52A8;&#x6001;&#x539F;&#x578B;&#x6A21;&#x5F0F;"></a>&#x52A8;&#x6001;&#x539F;&#x578B;&#x6A21;&#x5F0F;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#寄生构造函数模式"><span class="nav-number">3.6.</span> <span class="nav-text"><a href="#&#x5BC4;&#x751F;&#x6784;&#x9020;&#x51FD;&#x6570;&#x6A21;&#x5F0F;" class="headerlink" title="&#x5BC4;&#x751F;&#x6784;&#x9020;&#x51FD;&#x6570;&#x6A21;&#x5F0F;"></a>&#x5BC4;&#x751F;&#x6784;&#x9020;&#x51FD;&#x6570;&#x6A21;&#x5F0F;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#稳妥构造函数模式"><span class="nav-number">3.7.</span> <span class="nav-text"><a href="#&#x7A33;&#x59A5;&#x6784;&#x9020;&#x51FD;&#x6570;&#x6A21;&#x5F0F;" class="headerlink" title="&#x7A33;&#x59A5;&#x6784;&#x9020;&#x51FD;&#x6570;&#x6A21;&#x5F0F;"></a>&#x7A33;&#x59A5;&#x6784;&#x9020;&#x51FD;&#x6570;&#x6A21;&#x5F0F;</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#继承"><span class="nav-number">4.</span> <span class="nav-text"><a href="#&#x7EE7;&#x627F;" class="headerlink" title="&#x7EE7;&#x627F;"></a>&#x7EE7;&#x627F;</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#原型链"><span class="nav-number">4.1.</span> <span class="nav-text"><a href="#&#x539F;&#x578B;&#x94FE;" class="headerlink" title="&#x539F;&#x578B;&#x94FE;"></a>&#x539F;&#x578B;&#x94FE;</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#基本模式"><span class="nav-number">4.1.1.</span> <span class="nav-text"><a href="#&#x57FA;&#x672C;&#x6A21;&#x5F0F;" class="headerlink" title="&#x57FA;&#x672C;&#x6A21;&#x5F0F;"></a>&#x57FA;&#x672C;&#x6A21;&#x5F0F;</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#确定原型与实例关系"><span class="nav-number">4.1.2.</span> <span class="nav-text"><a href="#&#x786E;&#x5B9A;&#x539F;&#x578B;&#x4E0E;&#x5B9E;&#x4F8B;&#x5173;&#x7CFB;" class="headerlink" title="&#x786E;&#x5B9A;&#x539F;&#x578B;&#x4E0E;&#x5B9E;&#x4F8B;&#x5173;&#x7CFB;"></a>&#x786E;&#x5B9A;&#x539F;&#x578B;&#x4E0E;&#x5B9E;&#x4F8B;&#x5173;&#x7CFB;</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#原型链问题"><span class="nav-number">4.1.3.</span> <span class="nav-text"><a href="#&#x539F;&#x578B;&#x94FE;&#x95EE;&#x9898;" class="headerlink" title="&#x539F;&#x578B;&#x94FE;&#x95EE;&#x9898;"></a>&#x539F;&#x578B;&#x94FE;&#x95EE;&#x9898;</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#借用构造函数-经典继承-伪造对象"><span class="nav-number">4.2.</span> <span class="nav-text"><a href="#&#x501F;&#x7528;&#x6784;&#x9020;&#x51FD;&#x6570;-&#x7ECF;&#x5178;&#x7EE7;&#x627F;-&#x4F2A;&#x9020;&#x5BF9;&#x8C61;" class="headerlink" title="&#x501F;&#x7528;&#x6784;&#x9020;&#x51FD;&#x6570;(&#x7ECF;&#x5178;&#x7EE7;&#x627F;/&#x4F2A;&#x9020;&#x5BF9;&#x8C61;)"></a>&#x501F;&#x7528;&#x6784;&#x9020;&#x51FD;&#x6570;(&#x7ECF;&#x5178;&#x7EE7;&#x627F;/&#x4F2A;&#x9020;&#x5BF9;&#x8C61;)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#基本模式-1"><span class="nav-number">4.2.1.</span> <span class="nav-text"><a href="#&#x57FA;&#x672C;&#x6A21;&#x5F0F;-1" class="headerlink" title="&#x57FA;&#x672C;&#x6A21;&#x5F0F;"></a>&#x57FA;&#x672C;&#x6A21;&#x5F0F;</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#问题"><span class="nav-number">4.2.2.</span> <span class="nav-text"><a href="#&#x95EE;&#x9898;" class="headerlink" title="&#x95EE;&#x9898;"></a>&#x95EE;&#x9898;</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#组合继承-伪经典继承"><span class="nav-number">4.3.</span> <span class="nav-text"><a href="#&#x7EC4;&#x5408;&#x7EE7;&#x627F;-&#x4F2A;&#x7ECF;&#x5178;&#x7EE7;&#x627F;" class="headerlink" title="&#x7EC4;&#x5408;&#x7EE7;&#x627F;(&#x4F2A;&#x7ECF;&#x5178;&#x7EE7;&#x627F;)"></a>&#x7EC4;&#x5408;&#x7EE7;&#x627F;(&#x4F2A;&#x7ECF;&#x5178;&#x7EE7;&#x627F;)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#基本模式-2"><span class="nav-number">4.3.1.</span> <span class="nav-text"><a href="#&#x57FA;&#x672C;&#x6A21;&#x5F0F;-2" class="headerlink" title="&#x57FA;&#x672C;&#x6A21;&#x5F0F;"></a>&#x57FA;&#x672C;&#x6A21;&#x5F0F;</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#原型式继承"><span class="nav-number">4.4.</span> <span class="nav-text"><a href="#&#x539F;&#x578B;&#x5F0F;&#x7EE7;&#x627F;" class="headerlink" title="&#x539F;&#x578B;&#x5F0F;&#x7EE7;&#x627F;"></a>&#x539F;&#x578B;&#x5F0F;&#x7EE7;&#x627F;</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#基本模式-3"><span class="nav-number">4.4.1.</span> <span class="nav-text"><a href="#&#x57FA;&#x672C;&#x6A21;&#x5F0F;-3" class="headerlink" title="&#x57FA;&#x672C;&#x6A21;&#x5F0F;"></a>&#x57FA;&#x672C;&#x6A21;&#x5F0F;</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Object-create"><span class="nav-number">4.4.2.</span> <span class="nav-text"><a href="#Object-create" class="headerlink" title="Object.create"></a>Object.create</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#寄生式继承"><span class="nav-number">4.5.</span> <span class="nav-text"><a href="#&#x5BC4;&#x751F;&#x5F0F;&#x7EE7;&#x627F;" class="headerlink" title="&#x5BC4;&#x751F;&#x5F0F;&#x7EE7;&#x627F;"></a>&#x5BC4;&#x751F;&#x5F0F;&#x7EE7;&#x627F;</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#基本模式-4"><span class="nav-number">4.5.1.</span> <span class="nav-text"><a href="#&#x57FA;&#x672C;&#x6A21;&#x5F0F;-4" class="headerlink" title="&#x57FA;&#x672C;&#x6A21;&#x5F0F;"></a>&#x57FA;&#x672C;&#x6A21;&#x5F0F;</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#寄生组合式继承"><span class="nav-number">4.6.</span> <span class="nav-text"><a href="#&#x5BC4;&#x751F;&#x7EC4;&#x5408;&#x5F0F;&#x7EE7;&#x627F;" class="headerlink" title="&#x5BC4;&#x751F;&#x7EC4;&#x5408;&#x5F0F;&#x7EE7;&#x627F;"></a>&#x5BC4;&#x751F;&#x7EC4;&#x5408;&#x5F0F;&#x7EE7;&#x627F;</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#基本模式-5"><span class="nav-number">4.6.1.</span> <span class="nav-text"><a href="#&#x57FA;&#x672C;&#x6A21;&#x5F0F;-5" class="headerlink" title="&#x57FA;&#x672C;&#x6A21;&#x5F0F;"></a>&#x57FA;&#x672C;&#x6A21;&#x5F0F;</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yvonne</span>

  
</div>


  <div class="powered-by">Erstellt mit  <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
